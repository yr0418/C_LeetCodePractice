# 简单算法分析

---

## 1 移除链表元素

删除链表中等于给定值 ***val\*** 的所有节点。

示例:

- 输入: 1->2->6->3->4->5->6, val = 6
- 输出: 1->2->3->4->5



### 1.1 解法：哨兵节点

如果删除的节点是中间的节点，则问题似乎非常简单：

- 选择要删除节点的前一个结点 `prev`。
- 将 `prev` 的 `next` 设置为要删除结点的 `next`。

![在这里插入图片描述](数据结构算法.assets/1.1-1.png)



当要删除的一个或多个节点位于链表的头部时，事情会变得复杂。

![在这里插入图片描述](数据结构算法.assets/1.1-2.png)

可以通过哨兵节点去解决它，哨兵节点广泛应用于树和链表中，如伪头、伪尾、标记等，它们是纯功能的，通常不保存任何数据，其主要目的是使链表标准化，如使链表永不为空、永不无头、简化插入和删除。

![在这里插入图片描述](数据结构算法.assets/1.1-3.png)

在这里哨兵节点将被用于伪头。

算法：

1. 初始化哨兵节点为 ListNode(0) 且设置 sentinel.next = head。
2. 初始化两个指针 curr 和 prev 指向当前节点和前继节点。
3. 当 curr != nullptr：

   - 比较当前节点和要删除的节点：

     1. 若当前节点就是要删除的节点：则 prev.next = curr.next。
     2. 否则设 prve = curr。

   - 遍历下一个元素：curr = curr.next。
4. 返回 sentinel.next。

```c++
ListNode* removeElements(ListNode *head, int val) {
    ListNode* sentinel = new ListNode(0);
    sentinel->next = head;

    ListNode *prev = sentinel, *curr = head, *toDelete = nullptr;
    while (curr != nullptr) {
      if (curr->val == val) {
        prev->next = curr->next;
        toDelete = curr;
      } else prev = curr;

      curr = curr->next;

      if (toDelete != nullptr) {
        delete toDelete;
        toDelete = nullptr;
      }
    }

    ListNode *ret = sentinel->next;
    delete sentinel;
    return ret;
}
```

---



## 2 逆转单链表

反转一个单链表。

**示例:**

- 输入: 1->2->3->4->5->NULL
- 输出: 5->4->3->2->1->NULL



### 2.1 解法：链表拆分

1. 将一个链表拆分为两部分：
   1. L1：只包含头结点，且 $head->next = null$
   2. L2：包含剩下的全部节点，利用 $curr = head->next$，保存
2. 创建 $right， curr$ 两个指针，right 指向 curr 的下一位，每次遍历，将 curr 添加到 L1；curr，right 顺次下移
3. 当 $curr = null$ 时，遍历结束。

```c++
//反转单链表
ListNode* reverseList(ListNode* head) {
    //哨兵节点，类似头结点
    ListNode* sentinel = new ListNode(0);
    sentinel->next = head;

    ListNode *right, *curr;
    curr = sentinel->next;
    sentinel->next = nullptr;
    while (curr != nullptr){
        right = curr->next;
        curr->next = sentinel->next;
        sentinel->next = curr;
        curr = right;
    }
    head = sentinel->next;
    delete sentinel;
    return head;
}
```

---



















# 数据结构

---

## 1 单链表

```c++
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
 };

//尾插法创建不带表头节点单链表，先进先出
int initNodeList_01(ListNode *&L, int a[], int length){
    ListNode *s, *r;
    L = (ListNode *)malloc(sizeof(ListNode));
    L->next = NULL;
    r = L;
    for (int i = 0; i < length; i++){
        s = (ListNode *)malloc(sizeof(ListNode));
        s->val = a[i];
        r->next = s; s->next = NULL;
        r = s;
    }
    //头结点后移一位，使得不带头结点
    L = L->next;
    return OK;
}

//顺序打印链表
void printNodeList(ListNode *L){
    ListNode *p;
    p = L;
    while (p){
        printf("%d  ", p->val);
        p = p->next;
    }
    printf("\n");
}
```

