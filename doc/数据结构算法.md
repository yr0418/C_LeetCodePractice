# 简单算法分析

---

## 1 移除链表元素

删除链表中等于给定值 ***val\*** 的所有节点。

示例:

- 输入: 1->2->6->3->4->5->6, val = 6
- 输出: 1->2->3->4->5



### 1.1 解法：哨兵节点

如果删除的节点是中间的节点，则问题似乎非常简单：

- 选择要删除节点的前一个结点 `prev`。
- 将 `prev` 的 `next` 设置为要删除结点的 `next`。

![在这里插入图片描述](数据结构算法.assets/1.1-1.png)



当要删除的一个或多个节点位于链表的头部时，事情会变得复杂。

![在这里插入图片描述](数据结构算法.assets/1.1-2.png)

可以通过哨兵节点去解决它，哨兵节点广泛应用于树和链表中，如伪头、伪尾、标记等，它们是纯功能的，通常不保存任何数据，其主要目的是使链表标准化，如使链表永不为空、永不无头、简化插入和删除。

![在这里插入图片描述](数据结构算法.assets/1.1-3.png)

在这里哨兵节点将被用于伪头。

算法：

1. 初始化哨兵节点为 ListNode(0) 且设置 sentinel.next = head。
2. 初始化两个指针 curr 和 prev 指向当前节点和前继节点。
3. 当 curr != nullptr：

   - 比较当前节点和要删除的节点：

     1. 若当前节点就是要删除的节点：则 prev.next = curr.next。
     2. 否则设 prve = curr。

   - 遍历下一个元素：curr = curr.next。
4. 返回 sentinel.next。

```c++
ListNode* removeElements(ListNode *head, int val) {
    ListNode* sentinel = new ListNode(0);
    sentinel->next = head;

    ListNode *prev = sentinel, *curr = head, *toDelete = nullptr;
    while (curr != nullptr) {
      if (curr->val == val) {
        prev->next = curr->next;
        toDelete = curr;
      } else prev = curr;

      curr = curr->next;

      if (toDelete != nullptr) {
        delete toDelete;
        toDelete = nullptr;
      }
    }

    ListNode *ret = sentinel->next;
    delete sentinel;
    return ret;
}
```

---



## 2 逆转单链表

反转一个单链表。

**示例:**

- 输入: 1->2->3->4->5->NULL
- 输出: 5->4->3->2->1->NULL



### 2.1 解法：链表拆分

1. 将一个链表拆分为两部分：
   1. L1：只包含头结点，且 $head->next = null$
   2. L2：包含剩下的全部节点，利用 $curr = head->next$，保存
2. 创建 $right， curr$ 两个指针，right 指向 curr 的下一位，每次遍历，将 curr 添加到 L1；curr，right 顺次下移
3. 当 $curr = null$ 时，遍历结束。

```c++
//反转单链表
ListNode* reverseList(ListNode* head) {
    //哨兵节点，类似头结点
    ListNode* sentinel = new ListNode(0);
    sentinel->next = head;

    ListNode *right, *curr;
    curr = sentinel->next;
    sentinel->next = nullptr;
    while (curr != nullptr){
        right = curr->next;
        curr->next = sentinel->next;
        sentinel->next = curr;
        curr = right;
    }
    head = sentinel->next;
    delete sentinel;
    return head;
}
```

---



## 3 用队列实现栈

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通队列的全部四种操作（push、top、pop 和 empty）。

实现 MyStack 类：

- void push(int x) 将元素 x 压入栈顶。
- int pop() 移除并返回栈顶元素。
- int top() 返回栈顶元素。
- boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。

注意：

1. 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
2. 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列，只要是标准的队列操作即可。

示例：

- 输入：
  ["MyStack", "push", "push", "top", "pop", "empty"]
  [[], [1], [2], [], [], []]
- 输出：
  [null, null, null, 2, 2, false]
- 解释：
  MyStack myStack = new MyStack();
  myStack.push(1);
  myStack.push(2);
  myStack.top(); // 返回 2
  myStack.pop(); // 返回 2
  myStack.empty(); // 返回 False



### 3.1 解法一：两个队列

为了满足栈的特性，即最后入栈的元素最先出栈，在使用队列实现栈时，应满足队列前端的元素是最后入栈的元素。

可以使用两个队列实现栈的操作，其中 $\textit{queue}_1$ 用于存储栈内的元素，$\textit{queue}_2$ 作为入栈操作的辅助队列。

入栈操作时，首先将元素入队到 $\textit{queue}_2$ ，然后将 $\textit{queue}_1$ 的全部元素依次出队并入队到 $\textit{queue}_2$ ，此时 $\textit{queue}_2$ 的前端的元素即为新入栈的元素，再将 $\textit{queue}_1$ 和 $\textit{queue}_2$ 互换，则 $\textit{queue}_1$ 的元素即为栈内的元素，$\textit{queue}_1$ 的前端和后端分别对应栈顶和栈底。

由于每次入栈操作都确保 $\textit{queue}_1$ 的前端元素为栈顶元素，因此出栈操作和获得栈顶元素操作都可以简单实现。出栈操作只需要移除 $\textit{queue}_1$ 的前端元素并返回即可，获得栈顶元素操作只需要获得 $\textit{queue}_1$ 的前端元素并返回即可（不移除元素）。

由于 $\textit{queue}_1$ 用于存储栈内的元素，判断栈是否为空时，只需要判断 $\textit{queue}_1$ 是否为空即可。

![fig1](数据结构算法.assets/225_fig1.gif)

```c++
class MyStack {
public:
    queue<int> queue1;
    queue<int> queue2;

    /** Initialize your data structure here. */
    MyStack() {

    }

    /** Push element x onto stack. */
    void push(int x) {
        queue2.push(x);
        while (!queue1.empty()) {
            queue2.push(queue1.front());
            queue1.pop();
        }
        swap(queue1, queue2);
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int r = queue1.front();
        queue1.pop();
        return r;
    }
    
    /** Get the top element. */
    int top() {
        int r = queue1.front();
        return r;
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        return queue1.empty();
    }
};
```



### 3.2 解法二：一个队列

方法一使用了两个队列实现栈的操作，也可以使用一个队列实现栈的操作。

使用一个队列时，为了满足栈的特性，即最后入栈的元素最先出栈，同样需要满足队列前端的元素是最后入栈的元素。

入栈操作时，首先获得入栈前的元素个数 n，然后将元素入队到队列，再将队列中的前 n 个元素（即除了新入栈的元素之外的全部元素）依次出队并入队到队列，此时队列的前端的元素即为新入栈的元素，且队列的前端和后端分别对应栈顶和栈底。

由于每次入栈操作都确保队列的前端元素为栈顶元素，因此出栈操作和获得栈顶元素操作都可以简单实现。出栈操作只需要移除队列的前端元素并返回即可，获得栈顶元素操作只需要获得队列的前端元素并返回即可（不移除元素）。

由于队列用于存储栈内的元素，判断栈是否为空时，只需要判断队列是否为空即可。

![fig2](数据结构算法.assets/225_fig2.gif)

```c++
class MyStack {
public:
    queue<int> q;

    /** Initialize your data structure here. */
    MyStack() {

    }

    /** Push element x onto stack. */
    void push(int x) {
        int n = q.size();
        q.push(x);
        for (int i = 0; i < n; i++) {
            q.push(q.front());
            q.pop();
        }
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int r = q.front();
        q.pop();
        return r;
    }
    
    /** Get the top element. */
    int top() {
        int r = q.front();
        return r;
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        return q.empty();
    }
};
```

---



## 4 反转二叉树

翻转一棵二叉树。

示例：

- 输入：

  ```text
       4
     /   \
    2     7
   / \   / \
  1   3 6   9
  ```

- 输出：

  ```text
       4
     /   \
    7     2
   / \   / \
  9   6 3   1
  ```



### 4.1 解法一：从根节点开始反转

从根节点开始反转，从上往下进行递归

```c++
//反转二叉树，从根节点开始反转，顺次递归
TreeNode* invertTree_1(TreeNode* root) {
    if (root == nullptr){
        return root;
    }
  
    //反转左右子树  
    TreeNode* curr = new TreeNode();
    curr = root->left;
    root->left = root->right;
    root->right = curr;
  
    //顺次递归
    invertTree_1(root->left);
    invertTree_1(root->right);
    return root;
}
```



### 4.2 解法二：从叶子节点开始反转

从根节点开始，递归地对树进行遍历，并从叶子结点先开始翻转。如果当前遍历到的节点 \textit{root}root 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以 \textit{root}root 为根节点的整棵子树的翻转。

```c++
//反转二叉树，从叶子节点开始反转，从下往上递归
TreeNode* invertTree(TreeNode* root) {
    if (root == nullptr) {
        return nullptr;
    }

    TreeNode* left = invertTree(root->left);
    TreeNode* right = invertTree(root->right);
    root->left = right;
    root->right = left;
    return root;
}
```

---











# 数据结构

---

## 1 单链表

```c++
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
 };

//尾插法创建不带表头节点单链表，先进先出
int initNodeList_01(ListNode *&L, int a[], int length){
    ListNode *s, *r;
    L = (ListNode *)malloc(sizeof(ListNode));
    L->next = NULL;
    r = L;
    for (int i = 0; i < length; i++){
        s = (ListNode *)malloc(sizeof(ListNode));
        s->val = a[i];
        r->next = s; s->next = NULL;
        r = s;
    }
    //头结点后移一位，使得不带头结点
    L = L->next;
    return OK;
}

//顺序打印链表
void printNodeList(ListNode *L){
    ListNode *p;
    p = L;
    while (p){
        printf("%d  ", p->val);
        p = p->next;
    }
    printf("\n");
}
```

---



## 2 二叉树

```c++
//定义二叉树
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 };
```

